# Chapter별 Summary
## 1. 사용자 인터페이스
1. 명령어 옵션 처라하기 - getopts.sh
    * 옵션해석 내부 명령어 (getopts) 사용
    * case의 끝엔 esac(이삭 먹고 싶네ㅎㅎ)을 쓴다
    * shift $(expr $OPTION -1 ) - 많이 쓰이는 관용적인 표현
        * expr은 사칙연산 명령어로 사용

2. 키보드에서 Ctrl + C를 입력했을 때 현재 상태를 출력하며 종료하기 - sigint.sh
    * trap 명령어
        * 시그널 받았을 때 처리
        * Ex) trap ‘ date; exit ` INT 
            * Format - trap ‘하고싶은처리', 시그널
    * Ctrl + C 는 SIGINT 시그널 발생

3. 키보드에서 사용자 키 입력을 획득해서 변숫값으로 이용하기 - read.sh
    * 키보드값 얻기 위해서 read 명령어 사용
        * Ex) read id
        * 복수개 입력 
            * read id name number
    * echo -n : 줄을 바꾸지 않고 메시지를 출력

4. 암호 입력 시 사용자 키 입력을 표시하지 않기 - pass_wget.sh
    * stty 에코백 터미널 설정 변경
        * 에코백 OFF
            * stty -echo
        * 에코백 ON
            * stty echo
    * wget 명령어
        * --password 옵션
        * -q 옵션(quiet 모드)

5. 사용자 키 입력을 한 글자만 받기 - getchar.sh
    * stty 명령어를 이용해 터미널을 raw 모드로 변경
        * raw모드는 키 버퍼를 처리하지 않으므로 문자마다 처리
    * mac에서는 -n이 문자열로 그대로 출력된다?
        * Why? echo가 셸의 내부 명령어로 실행되서
        * 셸 스크립트에서 이용하는 명령어
            * 내부명령어
            * 외부명령어
                * Ex) bin/echo
        * echo -n “~” => /bin/echo -n “~"으로 변경
        * 또는 prinf사용
    * 키보드에서 문자 하나 읽기
    * char=$(dd bs=1 count=1 2> /dev/null)

6. 파일을 읽어서 처리할 때 키보드에서 입력받기 - read-redirect.sh
    * 명령어 치환
        * 명령행을 `로 감싸면 그 부분을 명령어 실행된 결과로 바뀜
    * tty
        * /dev/ttys003
        * 표준입력이 리다이렉트된 처리 안에서도 단말정보를 직접 리다이렉트하면 
이미 다른 read 명령어로 리다이렉트하고 있더라고 키보드 입력을 받을수 있다.

7. 선택식 메뉴를 표시해서 입력된 숫자값 처리하기 - select.sh
    * Case문
        * case $variable in
  a)
     logic
     ;;
  b)
     logic
     ;;
  *)
     logic
     ;;
esac
(이삭 토스트 ㅎ)

8. 표시 문자 색 변경하기 - color.sh 
    * echo -e 옵션 
        * 색깔 지정
            * 파라미터로 지정가능
                * 다수 파라미터는 ;로 나열
        * 이스케이프 시퀀스 문법
            * \033[파라미터1;파라미터2m 표시할 문자열 \033[0m]
        * Mac에선 -e옵션 생략 가능

9. 달력을 이용해 특정 날짜의 로그 파일 삭제하기 - dialog-calendar.sh
    * dialog 설치
        * Mac 
            * brew install dialog 
        * centOs
            * yum install dialog
        * 우분투
            * apt-get install dialog
    * dialog 옵션
        * --yesno
            * 명령어 종료 스테이터스 - $?
                * yes면 0 ,no면 1
    * 이스케이프 시퀀스 작성법
        * dialog —calendar text height width
            * text : 표시할 문자메세지
            * height : 문자 메시지 줄 수
            * width: 다이얼로그 박스 폭
    * awk -f / ‘{print $3$2$1}’ cal.tmp
        * 구분자 지정
    * If [ -z “$date_str$” ]; then
        * -z 빈문자열 체크
    * rm -i
        * 삭제 전 확인

10. 파일 압축 시 실행 상태를 표시하는 진행바 표시하기 - tar-pv.sh
    * tar 명령어
        * v옵션 : 현재 처리중인 파일 표시
        * c옵션 : 아카이브 작성
        * f옵션 : 아카이브 파일 작성
    * pv 설치
        * Mac
            * brew install pv
        * 가시화 예제
            * 700MB 0:00:42 [16.MB/s] [   <=>. ]
            * 파이프처리한 데이터크기 처리시간 평균속도 진행바
 
---

## 2. 변환처리
11. 실행 시 변숫값이 비어 있을 때 기본값을 정의해서 설정하기 - var-parameter.sh
    * ${변수명:=값} 
        * default 값 지정
    * 스크립트 앞부분에 변수를 우선 초기화 하고 싶을떄
        * : ${TEMPDIR:=/tmp}
    * :-, :?, :+
        * :- (변수값이 설정되어 있는지만 확인, 값은 덮어쓰지 않는다.)
        * :? (변수가 미정 또는 빈 문자열이면 message를 출력하고 스크립트 종료)
        * :+ (변수가 미정 또는 빈 문자열이면 null, 아니면 word)
            * ${var:+word}
        * 왜 안먹지??

12. 지역 변수를 함수 안에 정의해서 호출한 곳의 변수가 파괴되지 않게 하기 - local-var.sh
    * 지역변수 설정
        * local 명령어
            * ex) local DIR
        * DIR에 path를 추가할때
            * DIR=~/$1
                * 쌍따옴표 붙이면 안됨 , DIR=“~/$1” 하면 안됨.
    * 함수 호출 매개변수 
        * 함수 이름 ls_home
        * 호출시 ls_home logdir하면 ls_home에서 $1로 logdir을 접근할 수 있다.

13. HTML 파일에서 특정 속성값 얻기 - expo-match.sh
    * expr : 패턴 매칭 명령어
        * awk, sed보다 느리다.
        * expr 변수명 : 패턴
            * expr “$string” : “This is a \(.*\).”
        * 패턴 안에서 ()로 둘러싼 부분을 출력할 수 있다.
            * 괄호는 이스케이프 처리해야 하므로 실제 표기 방법은 “\(패턴\)”
        * 일치했을 때 종료 스테이터스 0
            * 특수 변수 $?로 접근 가능

14. 값이 정수인지 확인해서 계산하기 - int-check.sh
    * 사칙연산 expr 명령어 사용
        * expr $i + $j
        * expr $i - $j
        * expr $i \* $j(이스케이프 처리)
        * expr $i / $j
    * test 명령어
        * 처리의 종료스테이터스($?)
            * 명령행 인수가 test에서 비교대상 값과 같으면 0
            * 명령행 인수가 test에서 비교대상 값과 다르면 1
            * 명령행 인수가 test에서 비교대상 값과 비교 불가능한 문자열이면 2
    * dev/null 
        * 결과값 버릴때 리다이렉트 용도로 사용

15. 작은따옴표 안에서 작은따옴표 쓰기 - single-quote.sh
    * 따옴표 특징
        * 큰따옴표 
            * 큰따옴표로 둘러싼 문자열은 변수확장과 명령어 치환 됨
            * $와 `는 따옴표 안에서도 변수확장과 명령어 치환 의미를 그대로 가진다.
            * 큰따옴표 안에서 큰따옴표를 쓰려면 \기호
                * ex) str=“He said \”Hello!\"
        * 작은따옴표
            * 작은따옴표 기호는 단순한 따옴표로 ‘ 이외의 기호를 전부 그대로 출력(변수 확장 x)
            * 작은따옴표 안에서 작은따옴표를 쓰려면 \기호

16. 변수나 함수를 외부 파일로 작성하기 - source.sh
    * .(닷 명령어)로 외부 파일 읽어들임
        * 마치 소스 파일이 그대로 삽입된 것처럼 파일 내부 명령어가 실행
        * bash에선 .(닷 명령어)과 같은동작을 하는 source 명령어도 쓰임
    * test 명령어 -f 연산자로 파일 존재 여부 확인
        * ex) [ -f /etc/sysconfig/sshd ] && . /etc/sysconfig/sshd

17. 문장 속 공백 문자를 포함한 문자열 변수를 인수로 쓰기 - space-str.sh
    * 변수가 문자열을 넣고 사용할때는 "” 쌍따옴표 처리하자.
        * 공백문자가 들어가거나 빈 문자열일지도 모른다고 염두에 둬야함
        * 공백문자가 포함된 문자열이 저장된 변수를 따옴표 처리하지 않으면 쪼개진것처럼 인식
    * ex) 
        * result=“invalid value”
if [ “$result” = “invalid value” ]; then 처럼 처리

18. HTML 파일에서 태그 속에 적힌 주석을 추출해서 그대로 실행하기 - eval.sh
    * sed : 패턴 매칭 명령어(awk, expr등)
        * -n옵션 : 처리후에 패턴스페이스 출력 x
        * p플래그 : 일치했을때만 패턴 스페이스 출력
        * \1 : 후방참조
    * eval : 변수 확장을 해서 명령어 실행
        * 텍스트 문자열을 그냥 명령어로 실행하므로 위험
            * ex) rm -rf ~/*

    19. 언더스코어 등을 포함한 문자열에서 변수를 명확하게 구분하기 - varname.sh
    * 변수명으로 사용 가능한 문자는 알파벳, 숫자, 언더스코어
    * 셸 변수를 중괄호로 감싸자
    * ${today}_log
        * $today_log는 today_log를 하나의 변수로 인식함
    * 배열변수를 다룰때는 반드시 변수명에 {}
        * 배열 선언 
            * Declare
                * ex) declare -a number=(“zero”, “one”, “two”)
echo ${number[1]} => one
echo $number[1] => zero[1]

    20. 명령어 출력 결과를 파일명에 포함해서 그 파일명을 대상으로 명령어를 실행할 떄 보기 쉽게 하기 - comsub.sh
    * 명령어 치환 $() 표기법
        * ``를 사용하면 네스트(끼워넣기) 번거롭다.
            * 내부에 있는 `(그레이브)를 이스케이프 해야한다.
        * 처리를 네스트하더라도 기존 명령어 치환부분을 이스케이프 하지 않아도 된다.
    * 검색 카운트
        * grep -c

21. 미정의 변수를 에러로 처리해서 실수 방지하기 - set-u.sh
    * 미정의 변수를 참조하면 빈 문자열로 대체
        * rm 등에 경로명을 셸변수로 지정할때 치명적인 결과가 나타날수도..
    * set -u
        * 미정의 변수 참조시 에러 처리

22. 히어 도큐먼트에서 변수 확장하지 않고 그대로 $str처럼 표시하기 - here.sh
    * 히어 도큐먼트 종료 문자열을 작은따옴표로 감싼다.
    * 또는 이스케이프 처리 \$string(히어 도큐먼트 종료문자열이 작은따옴표로 감싸져 있지 않을시)
    * bash에는 히어도큐먼트(<<)와 닮은 히어 스트링(<<<)이 있다.
    
---

## 3. 파일처리
23. 절대 경로, 상대 경로 관계없이 같은 동작하기 - dirname.sh
    * dirname 명령어
        * 디렉터리 부분 추출 명령어
    * $0은 셸의 명령어 자체
        * ex) /home/user1/myapp.dirname.sh
        * 인수는 제외
    * 셸 스크립트 내부에서 다른 셸 스크립트를 실행할 때는 경로에 주의
        * cron 실행 시 현재 디렉터리가 cron실행 사용자의 홈 디렉터리가 된다.
    * 자신이 저장된 디렉터리에 cd 명령어로 이동해서 처리
    * dirname을 쓰지 않고 파라미터 확장을 이용해서 디렉토리 부분 취득 예
        * syntax : ${parameter%word} 
            * parameter값에서 word에 후방 일치하는 부분을 삭제한 값 취득
            * ex) cd “${0%/*)
                * 변수 $0 뒤에서부터 “/임의의 문자열”을 삭제한 값(디렉토리 부분 취득)

24. 명령어 사용법을 표시할 때 현재 파일명 표시하기 - basename.sh
    * basename 명령어
        * 경로부분을 제거하고 파일명 추출 명령어
    * $# = 인수 수가 들어있음
    * 파일명을 하드코딩하지 말자.
    * basename을 쓰지 않고 파라미터 확장을 이용해서 파일명 취득 예
        * syntax: ${parameter##word}
                * parameter값에서 word에 마지막으로 일치하는 부분을 삭제한 값
                * ex) prog=$(0##*/)
                    * 변수 $0에서 “임의의문자열/“을 삭제한 값(파일명 취득)

25. 디렉터리 이동한 다음 간단히 원래 장소로 돌아가기 - subcd.sh
    * 서브 셸
        * 현재 셸 안에서 새롭게 실행되는 셸
        * 서브셸은 자식프로세스, 호출한 곳은 부모 프로세스
        * 서브셸을 부른곳의 환경설정은 서브셸에 이어지지만 서브셸 내부에서 일어나는 변경은 호출한 원래 셸에는 영향 x
            * 서브셸 안에서 변숫값을 변경해도 원래 셸에는 반영 x

26. 디렉터리에 있는 파일과 디렉터리 수 조사하기 - findcount.sh
    * find 명령어
        * syntax : find [대상 경로] [서술식]
            * 서술식으로 주로 -name, -type
            * -name으로 특정 패턴 파일
            * -type은 파일종류
                * -type d, -type f, -type l등
                * -type d하면 대상경로가 먼저 표시.(실제 서브디렉터리 수보다 하나 더 플러스)
            * -maxdepth =1 서브디렉터리를 대상에서 제외

27. 파일 내용을 삭제해서 빈 파일로 만들기 - null.sh
    * uptime 명령어
        * 서버 부하 상태 확인
        * 로드 평균치(서버 부하)를 출력
    * : (널 명령어)
        * :(널명령어)를 리다이렉트
            * 파일 비우는데 자주 사용
            * touch명령어는 기존 파일이 있을 때 갱신일을 변경할 뿐 빈 파일 작성 x
        * 빈 파일을 만드는 다른 방법
            * cp /dev/null > $uptimelog
            * cat /dev/null > $uptimelog
            * true > $uptimelog
    * >> 
        * append, 추가 리다이렉트 명령어

28. 신규 파일을 만들지 않고 이미 있는 파일만 파일 갱신일을 바꾸기 - touch.sh
    * 파일 타임 스탬프
        * atime(최종 접근시각, access)
        * mtime(최종 수정시각, modify)
        * ctime(최종 상태변경시각, change)
        * stat 명령어
            * 파일 타임스탬프 확인
        * 타임 스탬프를 써서 파일 검색
            * find -mtime 옵션 사용
    * touch 명령어
        * -c 옵션 : 파일이 없으면 새로운 파일 만들지 않음.
        * -t 옵션 : 시각 갱신
            * atime, mtime 변경됨
    * 파일 존재 if문
        * if [ -e lock.tmp]; then

29. 여러 HTML 파일에서 title 태그만 추출해서 각각 다른 파일로 출력하기 - htmltitle.sh
    * 경로명 확장
        * ex)  for문 in뒤에 *.html 하면 경로명 확장이 일어나 각 파일을 순서대로 처리 가능
    * basename 명령어 두번째 인자로 확장명 제거
        * ex) basename $hemlfile .html
    * sed 
        * ex) sed -n “s/^.*<title>\(.*\)<\/title>.*$/\1/p” $htmlfile > output/${fanme}.txt

30. 특정 디렉터리에서 n일 전부터 m일 전까지 변경된 파일 목록 얻기 - find-mtime.sh
    * find 명령어
        * -name
        * -mtime
            * -mtime -3(3일전보다 새로운 파일)
            * -mtime 3(4일전~ 3일전 파일)
            * -mtime +3(4일전보다 오래된 파일)
        * 리눅스 -daystart
            * 현재 시각과 관계없이 오늘 0시0분부터
    * /bin/sh^M: bad interpreter eror 해결하는법
        * vi -b 바이너리 모드로 들어가 ^M 삭제

31. 작업 파일 디렉터리에서 1년 이상 갱신되지 않은 파일 삭제하기 - find-del.sh
    * find ~ -mtime + 364 (1년 이상 갱신이 없는 파일)
        * 구분자를 널 문자로 출력 print0
        * xargs 명령어
        * 파일목록을 인수로 받아서 임의의 명령 실행
    * rm 명령어
        * -f 옵션 : 해당 파일이 없을때도 에러 발생 x
        * -v 옵션 : 삭제한 파일명 표시
    * 테스트용 오래된 파일 생성
        * ex) touch -t 201611110123.45 data2.log

32. 로그 파일이 엄청 많은 디렉터리에서 파일들에 명령어를 일괄 실행하기 - xargs-grep.sh
    * 명령행 인수 상한값(ARG_MAX)
        * getconf ARG_MAX로 확인 가능
        * ex) grep ‘ERROR’ *.log로 하면 에러 발생할 수 있음.
    * xargs 명령어는 ARG_MAX값을 넘지 않도록 인수를 적당히 나눈다.
    * 대상파일에 dev/null추가
        * grep 명령어 출력에 반드시 파일명을 포함
        * grep 명령어에서는 여러 파일을 대상으로 할 때 앞부분에 파일명을 출력해 일치한 줄을 출력
            * 파일이 하나뿐이면 파일명 출력 x
            * /dev/null을 추가해서 늘 복수개의 파일을 대상으로 실행되도록 함

33. 파일을 백업할 때 파일명에 날짜 넣기 - datename.sh
    * date 명령어
        * 인수가 +로 시작할때 현재시각을 지정한 형식으로 표시
        * %Y: 년(1970~)
        * %y: 년도 아래 두글자(00~99)
        * %m: 월(01~12)
        * %d: 일(01~31)
        * %H: 시(00~23)
        * %M: 분(00~56)
        * %S: 초(00~59)
    * cp 명령어
        * -v (verbose)옵션 : 어떤파일을 어떤 파일명으로 복사하는지 표시
 
34. 파일들을 다른 디렉터리에 동기화해서 백업처리하기 - rsync.sh
    * rsync 명령어
        * 파일 차분만 갱신(차이를 바탕으로 갱신된 파일만 복사)
            * 복사 원본에서 삭제된 파일은 복사 대상에서 삭제되지 않는다.
                * --delete 옵션을 통해 완전히 동기화 가능
        * 파일 스탬프, 퍼미션, 소유자 정보등 파일속성 복사
        * syntax : rsync [옵션] <복사 원본> <복사 대상>
            * 복사 원본 디렉터리 지정시 마지막 슬레시 주의
                * 마지막 슬래시 있으면 디렉터리 자체 복사하지 않고 하위 파일과 서브디렉터리 복사
        * -a : 아카이브 모드
            * 자주 사용하는 옵션을 하나도 묶은 옵션
        * -v : verbose 모드, 상세모드
        * -n : 실제 파일은 복사하지 않고 대상 파일목록만 출력
        * 원격 서버 백업
            * ex) rsync -av /home/usr1/myapp/log user1@server1:/backup/myapp

35. 로컬 디렉터리에 파일을 만들지 않고 직접 원격 호스트에 아카이브 하기 - tar-ssh.sh
    * tar 명령어
        * syntax : tar [옵션] [생성 파일명.tar] [대상파일 또는 디렉토리]
            * cvf 뒤에 -를 지정해서 파일생성 없이 표준 출력에 표시
        * -c : 아카이브 작성
        * -v : verbose모드, 처리파일 표시
        * -f : 아카이브 파일 사용
        * -z : gzip 압축
    * 표준 출력을 파이프로 받아서 cat명령어로 리다이렉트(로컬에 파일을 만들지 않음)
    * 반대로 현재 호스트에서 원격호스트에 맞는 tar파일의 아카이브를 해제
        * ssh ${username}@${server} “cat backup/myapplog.tar” | tar xvf -

36. 중요한 파일을 암호 걸어서 zip으로 아카이브하기 - passzip.sh
    * zip 명령어
        * syntax : zip [ [옵션] <zip 파일> <대상 파일>
        * -r 옵션 : recursive
        * -e(Encrypte)

37. gzip 명령어로 압축률 높이기 - gzip.sh
    * gzip 명령어
        * -9 : 압축률 최대(1~9)
        * -c : output이 표준 출력
        * tar 명령어로 아카이브해서 압축할때 중간파일을 만들지 않아도 압축 가능
            * tar cf - log | gzip -9 -c > archive.tar.gz
        * 환경변수 설정으로 -9 옵션적용
            * GZIP=‘-9’; export GZIP
            
38. tar 아카이브할 때 일부 파일이나 디렉터리 제외하기 - tar-exclude.sh
    * tar 명령어
        * --exclude : 일부 파일이나 디렉터리 아카이브에서 제외
        * ex) txt 파일 제외
            * --exclude “*.txt” 
        * ex) .svn 디렉터리 제외
            * —exclude “.svn”
        * ex) 여러개 제외
            * —exclude “*.txt” —exclude “.svn"
        * -X : 외부 파일로 제외 목록 적용

39. tar 아카이브에 파일 추가하기 - tar-add.sh
    * tar 명령어
        * -t : 아카이브 파일 리스트
        * -r : 아카이브 파일 append
            * tar 아카이브 파일이 존재하지 않으면 새롭게 파일 작성.(에러 발생 x)
    * 월별마다 tar 아카이브 자동으로 작성할떄 유용(로그 파일 월 아카이브에 추가)

40. 파일 퍼미션과 타임 스탬프 등 원래 파일 속성을 유지한 채 파일 복사하기 - cp-p.sh
    * cp 명령어
        * -a : 타임스탬프와 퍼미션 유지
            * -R옵션도 동시 지정한것으로 봄
                * 리눅스에서 -a는 -dpR
                    * -d 심볼릭 링크 그대로 복사
                * Mac, FreeBSD에선 -a 는 -RpP
                    * -P 심볼릭 링크 그대로 복사
        * 옵션 없이 파일 복사하면 파일 퍼미션 umask로 설정한 값, 타임스탬프는 현재시간으로 변경
        * 디렉터리를 복사하지 않는다.
        * -R(recursive): 심볼릭 링크 자체 복사
        * -L: 심볼릭 링크가 가리키는 실제 파일을 복
        * -p: 파일 속성 유지
        * -r
            * 리눅스에서 심볼릭 링크 그대로 복사
            * FreeBSD에서는 심볼릭 링크가 가리키는 실제 파일 복사
    * ln
        * syntax : ln [source 파일] [target 파일]

41. HTML 파일인 .html과 .html 확장자를 txt로 일괄 변경하기
    * 파라미터 확장을 이용하여 파일명 취득
        * ${filename%.*)
    * case문 파일명 패턴 매칭
        * case “$filename” in
*.htm | *.html) 
;;
esac
    * for filename in *
        * in 뒤에 쌍따옴표를 붙이면 안되네
    * rename 명령어
        * ex) 
            * rename .htm .txt *.htm
rename .html .txt *.html

42. 처리 시작 전에 실행 권한을 확인해서 정상 동작이 가능한지 확인 후 실행하기
    * test, [ 명령어
        * 옵션
            * -x: 실행 권한 확인
            * -e: 파일이 존재하면 참
            * -d: 파일이 존재하고 디렉터리이면 참
            * -f: 파일이 존재하고 일반파일이면 참
            * -L(or -h): 파일이 존재하고 심볼릭 링크라면 참
            * -r: 파일이 존재하고 읽기 가능하면 참
            * -w: 파일이 존재하고 쓰기 가능하면 참
            * -x: 파일이 존재하고 실행 가능하면 참
        * expression -a expression: AND를 의미
            * ex) if [ -f “$start_command” -a -x “$start_command” ]; then
        * expression -o expression: OR를 의미
        * syntax
            * test expression or [expression]
            * [ 명령어는 마지막 인수로 닫는 괄호 ]가 필요
            * If [-x “$start_command”]; then
                * If test -x “$start_command”; then과 같다.
    * if문에는 test, [ 명령어뿐만 아니라 종료 스테이터를 판단하는 명령어는 뭐든 쓸수 있다(grep 등)
        * grep 명령어는 일치한 문자열이 있을 때는 종료스테이터스 0, 일치하지 않으면 1을 반환
    * && 
        * 앞 명령어가 성공하면 다음 명령어 실행
        * ex) test -x start.sh && ./start.sh
    * & 
        * Background 실행

43. 두 파일을 비교해서 오래된 파일 삭제하기
    *  test
        * -nt(newer than)
            * syntax : file1 -nt file2(file1이 file2보다 newer이면 참)
            * 두 타임스탬프가 같다면 거짓 반환
        * -ot(older than)
            * syntax : file1 -ne file2(file1이 file2보다 older이면 참)
    * 위치 파라미터 $1
        * 셸 함수 내부에서는 함수 인수

44. 두 디렉터리 비교해서 한쪽에만 있는 파일 표시하기
    * comm 명령어
        * syntax: comm file1 file2
        * 두 디렉터리 파일 목록 차분 출력
        * 각 열의 의미
            * 첫 열은 file1에만 있는 행 출력
            * 두번째 열은 file2에맞 있는 행 출력
            * 세번째 열은 양쪽에 공통된 행 출력
        * 입력파일이 정렬되어 있어야 함
        * diff 명령어와 약간 다름
        * 종료 스테이터스 
            * 두 파일의 차이가 있든지 없든지 종료스테이터스 0
            * 파일이 없거나 에러발생시 2
    * diff 명령어
        * 종료 스테이터스
            * 두 파일이 동일하면 종료스테이터스 0
            * 두 파일에 차이가 있으면 1
            * 파일이 없거나 에러 발생 시 2

45. 디렉터리에 있는 서브디렉터리들의 디스크 사용량 조사하기
    * du 명령어
        * 디스크 사용량 조사
        * 옵션
            * -k(킬로바이트 단위)
            * -m(메가바이트 단위)
            * -s: 실제로 인수로 지정한 대상의 디스크 사용량만을 표시, 서브 디렉터리의 사용량은 표시하지 않음
                * 그냥 실행하면 서브디렉터리도 표시
            * -h(human-readable)
    * sort 명령어
        * -r: reverse order
        * -n: 숫자 정렬

46. 작업 파일을 만들 때 내용을 읽지 못하도록 보안 대책 세우기
    * 스크립트 실행 중에 임시파일을 자주 만들지만 ID정보처럼 다른사람이 보면 안되는 정보를 기록하는 경우 사용
        * umask 명령어로 마스크값 설정해서 파일을 만들면 임시 파일권한 설정
    * umask 명령어
        * syntax: umask <마스크값>
        * 파일권한이 umask로 지정한 비트가 0이 되도록 작성됨
            * 셸 스크립트에서 만들어지면 666(디렉터리는 777)을 umask값으로 마스크한 값이 된다.
        * ex) umask 022로 지정했을때 만들어지는 파일권환은 644

47. 바이너리 파일에 포함된 문자열 얻기
    * 바이너리 파일에서 해당하는 에러메시지를 출력하는 명령어를 찾음.
    * strings 명령어
        * 바이너리 파일에서 문자열 추출(바이너리 파일이여도 문자열 상수는 그대로 저장되있음)
        * 옵션
            * -f: 문자열 표시 때 파일명 표시
                * mac에선 사용 불가능
                * for 반복문 처리
    * od 명령어(8진수 덤프), hexdump 명령어(16진수 덤프)
        * 바이너리 파일 내용을 살펴볼때
        * od -c
        * hexdump -C 

48. .svnc 등 숨은 파일과 디렉터리만 나열하기
            
