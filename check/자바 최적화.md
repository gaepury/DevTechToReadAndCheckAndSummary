# Chapter별 Check List
- [x] 1. 성능과 최적화?
- [x] 2. JVM 이야기
- [x] 3. 하드웨어와 운영체제
- [x] 4. 성능 테스트 패턴 및 안티패턴
- [ ] 5. 마이크로벤치마킹과 통계
- [ ] 6. 가비지 수집 기초
- [ ] 7. 가비지 수집 고급
- [ ] 8. GC 로깅, 모니터링, 튜닝, 툴
- [ ] 9. JVM의 코드 실행
- [ ] 10. JIT 컴파일의 세계로
- [ ] 11. 자바 언어의 성능 향상 기법
- [ ] 12. 동시 성능 기법
- [ ] 13. 프로파일링
- [ ] 14. 고성능 로깅 및 메시징
- [ ] 15. 지비 9와 미래

출처: 자바 최적화

# Chapter별 Summary
## 1. 성능과 최적화?
### 성능 분류
- 성능지표: 처리율(throughput), 지연(latency), 용량(capacity), 사용률(utilization), 효율(efficiency), 확장성(scalability(), 저하(degradation)
- 측정값 사이에는 서로 연결되있다. 

## 2. JVM 이야기
### 인터프리터와 클래스 로더
- JVM 인터프리터의 기본로직은, 평가 스택을 이용해 중간값들을 담아두고 가장 마지막에 실행된 명령어와 독립적으로 프로그램을 구성하는 옵코드(opcode)를 하나씩 순서대로 처리하는 **while 루프 안의 switch**문
- 클래스로더
   - bootstrap classloader: 다른 클래스 로더가 나머지 시스템에 필요한 클래스를 로드할수 있게 최소한의 클래스(예: java.lang.Object, Class, Classloader)만 로드
   - extension classloader(plaform classloader) OS나 플랫폼에 네이티브 코드를 제공하여 기본 환경을 오버라이드 할수 있다.
   - application classloader(system classloader)

### 바이트코드 실행
- javac를 이용하여 컴파일, javap(역어셈블리툴)로 디컴파일 
   - javap에 -v 옵션 추가시 클래스 파일 헤더 전체정보, 상수 풀 세부정보 표시
- 클래스 파일 해부도
   - ![image](https://user-images.githubusercontent.com/20143765/68543130-810a5e80-03f6-11ea-9dba-dc9701473c9d.png)
- 클래스 파일 구조를 암기하는 요령
   - ![image](https://user-images.githubusercontent.com/20143765/68543139-95e6f200-03f6-11ea-9267-aca78c26ad7b.png)
   
### 핫스팟 입문
- 핫스팟 JVM
   - ![image](https://user-images.githubusercontent.com/20143765/68543157-c4fd6380-03f6-11ea-94c7-8d9d28aa0fb8.png)
- AOT(Ahead-of-Time) 컴파일, JIT(Just-in-Time)컴파일
   - AOT 컴파일
      - 목표시스템의 기계어와 무관하게 중간언어 형태로 배포된 후 목표 시스템에서 인터프리너타 JIT 컴파일 등 기계어 번역을 통해 실행되는 중간 언어를 미리 목표 시스템에 맞는 기계어로 번역하는 방식
   - JIT 컴파일
      - 자바 프로그램은 바이트코드 인터프리터가 가상화한 스택머신에서 명령어를 실행하며 시작된다. CPU를 추상화한 구조라서 다른플랫폼에서도 클래스 파일은 문제없이 실행할 수 있지만, **프로그램이 성능을 최대로 내려면 네이티브 기능을 활용해 CPU에서 직접 프로그램을 실행시켜야 한다.** 이를 위해 프로그램 단위(메서드와 루프)를 인터프리티드 **바이트코드에서 네이티브 코드로 컴파일** 하는것을 JIT컴파일이라고 한다.
      - 인터프리티드 모드로 실행하는 동안 애플리케이션을 모니터링하면서 가장 자주 실행되는 코드 파트를 발견해 JIT 컴파일 수행 => 더 정교한 최적화
      - JVM에서 JIT 컴파일 후 실행되는 코드는 원본 자바 소스와는 전혀 딴판일 가능성이 높다.
      - 런타임정보를 활용하여 동적 인라이닝(dynami inlining), 가상 호출(virtual call)등으로 성능 개선
- Java는 PGO(profile-guided optimization)를 응용

### JVM 메모리 관리
- 가비지 수집

### 스레딩과 자바 메모리 모델(JMM)
- 주류 JVM 구현체에서 자바 애플리케이션 스레드는 각각 정확히 하나의 전용 OS스레드에 대응
   > 공유 스레드 풀을 이용해 전체 자바 애플리케이션 스레드를 실행하는 방안(그린 스레드)도 있지만, 복잡도만 증가시키고 만족할만한 수준의 성능은 나오지 않음.
   

### JVM 구현체 종류
- OenJDK, 오라클 자바, 줄루, 아이스티, 징, J9, 애비안, 안드로이드 등

### JVM 모니터링과 툴링
- JMX(java management extension), java agent, jvmti(JVM Toll Interface), SA(Serviceabilty Agent)
- java agent
  - ```-javaagent:<에이전트 Jar파일이 위치한 경로>=<옵션>
  - 에이전트 JAR파일에서 매니테스트 파일은 필수
- jvmti
  - ```-agentlib:<에이전트 라이브러리명>=<옵션>``` 또는 ```-ㅅagentpath:<에이전트 경로>=<옵션>- 
- VisualVM

## 3. 하드웨어와 운영체제
### 메모리
- CPU 클럭속도 증가에 따른 메모리 데이터 엑세스 지연 문제를 어떻게 해결할 것인가?
   - 메모리캐시
      - **각 실향코어에 전용 프라이빗 캐시 L1, L2를 두고, 일부 또는 전체 코어가 공유하는 L3 캐시를 둡니다.**
      - ![image](https://user-images.githubusercontent.com/20143765/68543359-58d02f00-03f9-11ea-85f7-d545ffee11df.png)
      - 메인메모리는 노스브리지 컴포넌트를 거쳐 액세스하고 이 버스를 관통함으로써 메인메모리 액세스 시간이 확 줄어든다
         > 노스브리지: CPU, 램, 바이오스 롬, PCI 익스프레스 그래픽 카드 사이의 통신, 사우스브리지는 IDE 컨토롤러 등의 주변장치와의 입출력 담당
      - 메모리에 있는 데이터를 어떻게 캐시로 가져오고 캐시한 데이터를 어떻게 메모리에 다시 써야 할지 결정 => cache consistency protocol(캐시 일관성 프로토콜)
         - MESI
            - Modified(수정): 데이터가 수정된 상태
            - Exclusive(베타): 이 캐시에만 존재하고 메인 메모리 내용과 동일한 상태
            - Shared(공유): 둘 이상의 캐시에 데이터가 들어있고 메모리 내용과 동일한 상태
            - Invalid(무효): 다른 프로세스가 데이터를 수정하여 무효한 상태
         - write-through => write-back

### 최신 프로세서의 특성
- TLB(Translation Lookaside Buffer:변환 색인 버퍼): 가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시 역할

#### 운영체제
- MMU(Memory Management Unit)를 통한 가상 주소 방식과 페이징 테이블은 메모리 액세스 제어의 핵심
- TLB는 물리 메모리 주소 룩업 시간을 줄이는 하드웨어 기능, 유저 입장에선 너무 저수준
- OS 액세스 스케줄러(OS 커널요소)
- 스케줄러
- 시간문제
   - OS마다 os::javaTimeMillis 구현 방식이 다름.
- 컨텍스트 교환
   - 비싼 작업(특히 커널-유저 스레드 사이 컨텍스트 교환)
      - 커널 모드로 컨텍스트가 교환되면 TLB를 비롯한 다른 캐시까지도 무효화
   - vDSO(virtual Dynamically Shared Object): 커널 privileges이 필요없는 시스템 콜의 속도를 높이려고 쓰는 유저 공간의 메모리
#### 단순 시스템 모델
- 애플리케이션이 실행되는 하드웨어와 OS, 애플리케이션이 실행되는 JVM/컨테이너, 애플리케이션 코드 자체, 애플리케이션이 호출하는 외부 시스템, 애플리케이션으로 유입되는 트래픽
   - 이들중 누구라도 성능 문제를 일으킬수 있다. 
#### 기본 감지 전략
- CPU 사용률
   - vmstat 사용
   - 튜닝이 잘된 프로그램은 리소스(특히 CPU)를 최대한 활용한다. CPU Bound 워크로드는 유저 공간의 CPU 사용률을 100% 가깝게 유지하는것이 목표
   - vmstat는 컨텍스트 교환 발생 횟수를 나타내므로 ```vmstat 1``` 명령어를 실행하면 **컨텍스트 교환의 실시간 영향도(cs field)** 를 지켜볼수 있다. 유저 공간에서 CPU 사용률이 100% 근처도 못갔는데 어떤 프로세스에서 컨텍스트 교환 비율이 높게 나타나면 I/O에서 블로킹이 일어났건, 스레드 락 경합 상황이 벌어졌을 공산이 크다.
- 가비지 수집
   - 핫스팟JVM은 시작시 메모리를 유저 공간에 할당/관리. 그래서 메모리를 할당하느라 시스템 콜을 할 필요가 없다. 즉 커널 교환을 할일이 거의 없다.
- 입출력
   - iostat 사용(블록-인, 블록-아웃)
   - 커널 바이패스 I/O
- 기계공감
   - 소프트 웨어 성능을 이해하기 위하여 하드웨어 지식은 매우 중요하다.
#### 가상화
- 가상화 특징
   - 가상화 OS에서 실행하는 프로그램은 비가상화 OS에서 실행할때와 동일하게 작용해야 한다.
   - 하이퍼바이저는 ㅁ모든 하드웨어 리소스 액세스를 조정해야 한다.
   - 가상화 오버헤드는 가급적 작아야 하며 실행시간의 상당부분을 차지해선 안된다.
- 비가상화 시스템에서 OS커널은 privilige 모드로 동작하므로 하드웨어를 직접 건드릴수 있지만, 가상화 시스템에서는 게스트 OS가 하드웨어에 직접 액세스 안됨
   - 대게 privilige 명령어를 unprivilieged 명령어로 고쳐씀
   - 컨텍스트 교환이 발생하는 동안 지나친 캐시 플러시(TLB)가 일어나지 않도록 OS커널의 자료구조는 shadow해야 한다.
   
#### JVM과 운영체제
   - JNI
     - os:javaTimeMillis()는 네이ㅣ브 메서드 System.currentTimeMillis()에 구현된 로직을 처리한다.
     - ![image](https://user-images.githubusercontent.com/20143765/68543578-2542d400-03fc-11ea-9a68-1ca2c4fde95f.png)

### 4. 성능 테스트 패턴 및 안티패턴
#### 성능 테스트 유형
- 지연테스트(Latency Test): 종단 트랜잭션에 걸리는 시간은?
- 처리율 테스트(Throughput Test): 현재 시스템이 처리 가능한 동시 트랜잭션 개수는?
- 부하 테스트(Load Test): **특정 부하**를 시스템이 감당할수 있는가?
- 스트레스 테스트(Streaa Test): 이 시스템의 **한계점**은 어디까지인가?
- 내구성 테스트(Endurance Test): 시스템을 장시간 실행할 경우 성능 이상 증상이 나타나는가?
- 용량 계획 테스트(Capacity planning Test): 리소스를 추가한 만큼 시스템이 확장되는가?
- 저하 테스트(Degradation): 시스템이 부분적으로 실패할 경우 어떤 일이 벌어지나?
#### 기본 베스트 프랙티스
- 기본원칙
   - 나의 관심사가 무엇인지 식별하고 그 측정 방법을 고민한다. 
   - 최적화하기 용이한 부분이 아니라, 중요한 부분을 최적화한ㄷ.
   - 중요한 관심사를 먼저 다룬다.
- 하향식 성능(전체 애플리케이션 성능 양상 => 코드 섹션별 성능 양상)
- 테스트 환경 구축
   - 운영환경과 최대한 비슷하게
- 성능 요건 식별
   - NRF(NonFunctional Requirement)
      - 95% 백분위 트랜잭션 시간을 100밀리초 줄인다.
      - 기존 하드웨어 처리율을 5배 높일 수 있게 시스템 개선한다.
      - 평균 응답 시간을 30% 줄인다.
- 자바에 특정한 이슈
   - JIT 컴파일을 유심히 보자
      - JIT 컴파일 안하기로 결정된 메서드는 둘중 하나
         1. JIT 컴파일할 정도로 자주 실행되는 메서드가 아니다.
         2. 메서드가 너무 크고 복잡해서 도저히 컴파일 분석을 할 수 없다.
- SDLC(Softeware Development Life Cycle)
   - 일류, 수준 높은 팀일수록 성능 테스트를 전체 SDLC의 일부로서 수행하며 특히 성능 회귀 테스트를 상시 수행 하는편
#### 성능 안티패턴 개요
- UAT(User Acceptance Testing)
- 지루함, 이력서 부풀리기, 또래 압박, 이해 부족, 오해와 있지도 않은 문제
#### 성능 안티패턴 카탈로그
1. 화려함에 사로잡히다.
2. 단순함에 사로잡히다.
3. 성능 튜닝 도사
4. 민간 튜닝
5. 안되면 조상 탓
6. 숲을 못보고 나무만 보다
7. 내 데스크톱이 UAT
8. 운영 데이터처럼 만들기는 어려워
#### 인지 평향과 성능 테스트
- 환언주의, 확증 편향, 행동편향, 위험 편향


